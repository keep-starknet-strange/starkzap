# Lessons

- When implementing end-user swap flows, never expose raw JSON call inputs in the primary UX.
- For Ekubo mobile integration, default to token-in/token-out/amount only, then fetch quote + build calls automatically at submit time.
- For protocol contract presets, verify addresses against live chain RPC (`starknet_getClassHashAt`) instead of trusting stale constants.
- On testnets, validate default token pair liquidity with the quote API and choose defaults that route reliably.
- When a user asks for an "interface," confirm and prioritize a reusable TypeScript contract first (SDK/API surface), then treat UI changes as secondary.
- For multi-provider swaps, keep base interfaces provider-neutral and move protocol-specific fields to provider request/quote generics.
- If the API feels cumbersome, add high-level convenience methods that hide low-level adapter plumbing while keeping low-level hooks for advanced flows.
- For AVNU on Sepolia, use chain-aware API base selection and surface no-route errors with actionable guidance (amount/pair/source), since low-size trades can legitimately return no routes.
- Convert slippage basis points to percentage using `/ 10000`, not `/ 100`.
- In React swap forms, avoid effects that blindly re-apply default tokens on every derived-list recompute; preserve user-selected tokens unless they become invalid.
- Prefer concrete swap provider types over generic-heavy signatures for app-facing APIs; keep the generic surface only where it adds real value.
- Remove redundant protocol-specific adapter request types when a provider already returns normalized `SwapPlan`; duplicate layers add cognitive load without new capability.
- If a public TS interface still feels complex after simplification, remove generics from that surface and accept `unknown` with runtime validation in protocol adapters.
- When users ask for a simple swap interface, make the provider contract explicit as `getQuote(request)` and `swap(request)` and avoid provider-side `prepare*` naming.
- For API ergonomics requests, prefer deleting low-level abstractions from the public surface instead of layering aliases/deprecations that keep complexity visible.
- When restoring a previously removed integration, reintroduce it against the current simplified API surface instead of bringing back legacy abstraction layers.
- For wallet ergonomics, keep explicit-provider swap methods but add request-only overloads so common usage mirrors simple helpers like `wallet.transfer(...)`.
- When adding ergonomic wallet helpers, provide intuitive names (`getQuote`) and keep previous names (`quoteSwap`) as aliases to avoid breaking callers.
- For multi-provider wallets, keep the request-first happy path but add provider-id overloads and a wallet-level provider registry for explicit routing.
- If users ask to "pass additional providers," support injection at wallet connection boundaries (`connectWallet`) rather than requiring post-connect imperative registration.
